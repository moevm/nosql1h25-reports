Doc.name: Реализация диффузионного декодера для задач распознавания речи
Doc.author: Е. А. Павлов
Doc.academic_supervisor: А.А. Лисс
Doc.year: 2024
len(Doc.structure): 4 Doc.name: Реализация диффузионного декодера для задач распознавания речи
len(DocSection.structure): 0 DocSection.name: None lvl: None
ОПРЕДЕЛЕНИЯ, ОБОЗНАЧЕНИЯ И СОКРАЩЕНИЯ  Токен – единица текста, обычно представляет собой несколько букв или слово. Токенизация – процесс преобразования исходного текст в последовательность токенов. Референсная транскрипция – истинная транскрипция аудиофрагмента с речью, чаще всего получена с помощью людей-разметчиков  Искуственная нейронная сеть (нейросеть) – математическая модель, в некотором ходе схожая с нейронными сетями живых организмов.  Диффузионные модели — это класс моделей скрытых переменных, которые обучаются итеративно преобразовывать случайный Гауссовский шум, который может быть сгенерирован аналитически, в наблюдения из данных с неизвестным распределением [8]. Автокодировщик  – класс искуственных нейронных сетей, который используется для получения оптимальных векторных представлений каких-либо данных [4] Лосс функция (функция потерь) – дифференцируемая функция, которая  даёт некоторую оценку на разницу между истинным ответом и предсказанием модели Эмбеддинг — векторое представление, полученное с помощью нейросети, чаще всего представляет собой промежуточное значение с какого-либо слоя Нейросети прямого распространения — один из 
простейших видов нейростей, состоит из матричных умножений и нелинейных функций активации Мультиголовый механизм самовнимания (multi-head self-attention) — один из типов слоёв искуственных нейронных сетей, предложенный в статье Attention is all you need [9] Леернорм (Layernorm) — один из типов слоёв искуственных нейронных сетей, выполняет нормировку входных данных по оси признаков, содержит два обучаемых параметра — разброс и смещение [24] Датасет — набор размеченных данных Тренировочный датасет (трейнсет) — датасет, используемый на этапе обучения модели Валидационный датасет (валсет) — датасет, используемый на этапе оценки модели, примеры из него строго не должно содержаться в тренировочном датасете Функция активации — нелинейная функция, используемая между линейными и квазилинейный преобразованиями в нейронных сетях с целью улучшения обощающей способности Self-supervised — способ обучения нейронной сети, в условиях малого количества размеченных данных, где сначала модель обучается на имеющихся размеченных данных, после чего используется для генерации разметки на неразмеченных данных, после чего полученная разметка используется для обучения 
следующей модели и так далее Свёрточный слой — один из типов слоёв искусственных нейронных сетей, вычисляет операцию свёртки между входными данными и фильтром, фильтр является обучаемым параметром Трансформер — архитектура искусственной нейронной сети, предложенная в статье [9], построенная на использовании  multi-head self-attention N-грамма — некоторое множество грамматических единиц текста, например, букв, слов или токенов Кодбук — заранее заданное множество векторов, чаще всего ортогональных, иногда кодбуки бывают обучаемыми Батч — множество объектов, представленных в виде матрицы или тензора большей размерности, используемых на одном прогоне модели Кросс-аттеншен — один из типов слоёв искусственых нейронных сетей, где механизм самовнимание получает в качестве key и query векторов данные из различных последовательностей Аугментации — различные незначительные преобразование входных данных, помогающие разнообразить обучающий датасет модели и увеличить её обощающую способность Позиционные эмбеддинги — специальная добавка ко входным данным модели, которая кодирует информацию о позиции элемента в последовательности
    len(DocSection.structure): 0 DocSection.name: ВВЕДЕНИЕ  lvl: 2
    В последнее время резко возросла потребность в распознавании речи в большом количестве сценариев. Задача перевод речи в текст возникает в системах видеоконференцсвязи, системах голосового управление и многих других. Также в последнее время большое развитие получили нейросетевые подходы к задаче распознавания, которые показывают лучшие результаты среди всех алгоритмов-конкурентов. Одним из новых типов искуственных нейронных сетей являются диффузионные модели, хорошо показавшие себя в нескольких классах задач. Всё это приводит к потребности в исследовании диффузионных моделей в задаче распознавания речи Цель работы: Исследовать потенциал использования диффузионных моделей в задаче распознавания речи Объектом исследования является диффузионные нейросетевые модели распознавания речи Предметом исследования является применимость нейросетевых алгоритмов, основанных на диффузии в непрерывных пространствах, в распознавании речи Для достижения поставленной цели требуется решить следующие задачи: 1. Анализ существующих решений 2. Выбор используемых методов 3. Реализация и обучения диффузионной модели 4. Оценка качества и сравнение с аналогами       
len(DocSection.structure): 5 DocSection.name: Структура lvl: None

    len(DocSection.structure): 2 DocSection.name:       1. Актуальность lvl: 2
    В современном мире большое количество информации представлено в аудиоформате и количество такой информации продолжает расти с каждым днём. Источниками такой информации могут послужлить системы телефонии, видеосвязи, стриминговые сервисы, а также множество других.  С ростом количества аудиоданных усложняется работа с ними на многих уровнях. Начиная со скорости восприятия информации — для человека намного быстрее прочитать транскрипцию, чем прослушать аудио 
— заканчивая более сложными задачами, по типу текстового поиска и составления краткого содержания. Всё это приводит к увеличению потребности в продвинутых системах распознавания речи. В настоящее время уже проведен ряд исследований 
в этой области, а также разработаны работоспособные системы. Однако ошибка таких систем не равна нулю, что вызывает потребность в проведении дальнейших исследований в этой области. Основным подходом к задаче распознавания речи является использования машинного обучения, а конкретно — глубокого обучения.  Глубокое обучение — раздел машинного обучения, занимающийся изучением и применением многослойных нейронных сетей. В последние годы эта область человеческого знания активно развивается, предлагаются новые подходы и методы по созданию нейросетевых алгоритмов. Такие алгоритмы хорошо показывают себя на большом классе задач — распознавание речи, сегментации изображений, генерации текста и фото.  Одним из последних достижений науки являются диффузионные модели, хорошо показавшие себя в задачах генерации изображений и речи [1], [2].
      len(DocSection.structure): 0 DocSection.name: 1.1 Применение систем распознавания речи в современном мире lvl: 3
      Как было сказано ранее, количество аудио контента, производимого человечеством позволяет расти, а работа с его содержанием путём прослушиванию вызывает всё больше трудностей. Также распознавать речь требуется не только в задачах, связанных с обработкой или поиском информации человеком, но и в задачах создания голосовых интерфейсов управления. Ниже представлен список возможных применений систем распознавания речи: 1. Видеоконференции В ходе пандемии COVID-19, а также нескольких последующих лет сильно возрасло количество ВКС, а также их аудитория. Такие системы используются в большом количестве организаций — корпорациях, образовательных и государственных учреждениях, сотрудники пользуются видеосвязью для проведения совещаний, лекций, планирований и иных встреч. Часто, в результате таких встреч требуется составить протокол встречи, чтобы после можно было вернуться к нему и получить доступ к информацию с прошедей встречи. 2. Телефония В большом количестве компанию существуют отделы продаж и технической поддержки, активно использующие в своей работе телефонную связь. Информация о содержании разговоров сотрудников может потребоваться для улучшения качество облуживания клиентов и проведения речевой аналитики. 3. Переводчики Ещё одним применением распознавания речи могут служить системы перевод. Большинство современных систем перевода работают на уровне текста, поэтому в 
сценарии, когда пользователь переводчика не знает языка и имеет доступ только к аудио информации, системы распознавания могут помочь ему с перевод аудио в текст для дальнейшего перевода на другой язык 4. Голосовые ассистенты Также распознавание речи может быть необходимо в голосовых ассистенах для понимания команд и запросов пользователя, озвученных голосом
      len(DocSection.structure): 0 DocSection.name: 1.2 Обоснование использования диффузионных моделей в задаче распознавания речи lvl: 3
      За небольшое количество времени диффузионные модели показали впечатляющие результаты в работе с изображениями и синтезе речи, а также нашли применение в генерации текста. Это позволяет ожидать, что и из их применения в задаче 
распознавания речи получится извечь выгоду
    len(DocSection.structure): 2 DocSection.name: 2. Обзор аналогов lvl: 2
    В этом разделе будут рассмотрены существующие подходы к задаче распознавания речи. Перед тем, как перейти к рассмотрению аналогов опишем задачу распознавания речи формально — на вход поступает цифровой аудиосигнал, а результатом является текст на каком-либо языке. Таким образом: X — входной вектор размером T, где T — количество дискретных измерений L — референсная транскрипция для аудиозаписи X Задача состоит в том, чтобы найти отображение из пространства 
X в пространство L. Так как данная задача не имеет аналитического решения в общем виде принято использовать различные модели, которые стараются оценить и аппроксиморовать данное отображение.
      len(DocSection.structure): 0 DocSection.name: 2.1 CTC — подходы lvl: 3
      Connectionist Temporal Classification (CTC) — метод при обучении нейронных сетей на задачу матчинга последовательностей без знания точного временного соответсвия между элементами последовательности. Обычно данный метод используется в задаче распознавания речи или задачи распознавания рукописного текста. Метод был предложен в 2006 году Алексом Грейсвом и его коллегами [22]. Для описания метода введём обозначения: x — входная последовательность из векторов размерности m T — длина последовательности x L — алфавит из элементов которого состоит выходная последовательность y — выходная последовательность, состоящая из элементов L  бланк (<blank>) — специально добавляемый символ алфавита, используется на декодировании L` — алфавит L, к которому добавили бланк N — мощность алфавита L` Алгоритм получаем на вход один вектор из m значений, а на выход выдаёт вероятностное распределение над алфавитом L`. В ходе обработки 
всей последовательности x, получается T вероятностых распределений над L`, обозначим их как матрицу A размера N на T. Введём понятие пути. Путь — это последовательность элементов матрицы A, которая однозначно определяет выходную последовательность z. Для такого пути (обозначием его l) можно построить оценку его вероятности, согласно следующей формуле: , где i — номер элемента выходной последовательности  l(i) — индекс в алфавите элемента, находящегося на позиции i в выходной последовательности P(y|x) — вероятность получить выходную последовательность x, при входной последовательности y. На этапе обучения нейронной сети есть набор (D) размеченных пар (x,y) — в данном случае аудио и речь. 
Тогда на обучении алгоритм будет по последовательности x генерировать матрицу вероятностей A, согласно которой будут рассчитываться оценки вероятностей для референсных транскрипций. На основе этих оценок будем считать следующую лосс-функцию: Которую будем оптимизировать с помощью изменения параметров модели. Однако при таком подходе есть проблема с распознаванием идущих подряд одинаковых элементов выходной последовательности. Допустим, есть два соседних, с точки зрения времени, распределения, максимальную вероятность в которых имеет один и тот же элемент. В такой ситуации нельзя разделить ситуации — один элемент на несколько временных отрезков или это два одинаковых элемента на соседних 
временных отрезках.  В задаче распознавания речи это наглядно видно в словах с повторяющимися буквами. Например, слово «стресс». Для разделения таких случаев и вводится бланк символ. Он вставляется между одинаковыми элементами алфавита и означает переход к следующему символу.  Тогда последовательности вида: {с, т, р, е, с, <blank>, с} будут переводится в «стресс», а последовательности вида {с, т, р, е, с, с}, будут приводится к виду «стресс». На представленном ниже рис. 1 можно видеть пример работы ctc: Рисунок 1 – Пример ctc на этапе получения выходной последовательности. По вертикали расположены элементы выходной последовательности, а по горизонтали входной. Глубина цвета означает вероятность, эпсилон — это бланк-символ Примером модели, обученной с помощью ctc может служить нейросеть с архитектурой Conformer [19].  Conformer — одна из первых удачных попыток совмещения свёртночных нейронных сетей и механизма самовнимания в задаче распознавания речи. Архитектура Conformer представлена на рис. 2. Рисунок 2 – Архитектура Conformer В начале модели идёт блок «Convolution Subsampling», который сжимает размер входной последовательности в 4 раза, что уменьшает требуемое количество вычислений. Далее следует последовательность из «Conformer Block»-ов - основного модуля этой архитектуры, состоящего из свёрток, сетей прямого распространения и механизма самовнимания, а также леернормов. Визуализацию «Conformer Block» можно видеть на рис. 2.
      len(DocSection.structure): 4 DocSection.name: 2.2 TransFusion lvl: 3
      Это диффузионная модель для распознавания речи, предложенная в статье [3]. Основная идея — обучить модель текстовой диффузии, у которой диффузионный процесс может быть обусловлен на вектороное представление аудио, содержащего 
человеческую речь.
        len(DocSection.structure): 0 DocSection.name: 2.2.1 Мультиноминальная диффузия lvl: 4
        Обычно диффузионные модели работают с вещественными представлениями данные, это могут быть эмбеддинги, картинки или спектрограммы. Однако текст имеет дискретную природу, поэтому авторы используют мультиноминальную диффузию предложенную в статье [15].  Конкретно мультиномильная диффузия определяется входы диффузионной модели, как последовательность дискретных элементов (символов или слов), представленных в виде векторов содержащих одну единицу, а остальное заполнено нулями.  Формальные обозначения: - индекс временного шага, T — количество временных шагов - индекс позиции в последовательности - вектора, представляющие элементы последовательности, размерность векторов совпадает с мощностью алфавита символов Мультиноминальная диффузия определяет прямой процесс диффузии следующим образом: ,  C обозначает категориальное распределение, - коэффициент расписания добавления шума,  Таким образом предиктор шума предсказывает на каждой итерации диффузии распределение над словарём
        len(DocSection.structure): 0 DocSection.name: 2.2.2 Получение векторных представлений аудио lvl: 4
        Для получения аудиоэмбеддингов авторы используют предобученную модель WavLM [16]. Данная модель обучалась на огромном количестве данных в self-supervised режиме, что позволило достичь высокой обобщающей способности внутренних представлений модели. Во время обучения предсказателя шума авторы не изменяют параметры WavLM, эмбеддинги строятся для каждых 20 миллисекунд исходного аудио. Модель содержит порядка 317 миллионов параметров и обучалась на данных объёмом порядка 94 тысяч часов.
        len(DocSection.structure): 0 DocSection.name: 2.2.3 Архитектура модели lvl: 4
        В качестве предсказателя шума авторы используют архитектуру нейросети на основе трансформера. Для обуславливания процесса диффузии на содержаниие аудио авторы добавляют небольшой блок состоящий из линейных проекций, нормировок и нелиненых функций активации. Всего сеть содержит 24 трансформер-блока и имеет 253 миллиона параметров, архитекутра представлена на рис. 3. Рисунок 3 – Архитектура предсказателя шума
        len(DocSection.structure): 0 DocSection.name: 2.2.4 Обучение модели lvl: 4
        Лосс функция, используемая авторами также берётся из статьи [15]. Так как основная цель при обучении диффузионной модель — это построение модели, которая будет предсказывать  максимально близкое к апостериорному распределению , то в качестве лосс-функции используется дивергенция Кульбака-Лейблера: При обучении используется 200 временных шагов диффузии, аудиоэмбеддинги из WavLM-large, используется оптимизатор AdamW [25] со значениями бет (0.9, 0.999) и 
с константным расписанием обучающих коэффициентов с разогревом 10000 итераций и пиковым значением . В качестве обучающего датасета используется LibriSpeech-960h, аугментации не используются.
    len(DocSection.structure): 11 DocSection.name: 3. Теоретическая часть lvl: 2

      len(DocSection.structure): 3 DocSection.name: 3.1 Обзор предметной области lvl: 3
      В данном разделе описан ряд понятий, используемых в большом количестве работ, а также при описании предлагаемого в данной работе решения.
        len(DocSection.structure): 0 DocSection.name: 3.1.1 Формальная постановка задачи lvl: 4
        На вход поступает аудиосигнал, содержащий один канал, который может быть представлен в виде вещественных или натуральных чисел. В общем случае аудио сигнал представляет собой вектор из , где N — количество отсчётов, полученных при дискретизации аналогового сигнала. На выход поступает последовательность из элементов из заранее известного конечного алфавита.
        len(DocSection.structure): 0 DocSection.name: 3.1.2 Метрики качества lvl: 4
        В задаче распознавания речи сущесвует огромное количество метрик, который пытаются оценивать те или иные аспекты качества. В данной работе будет использоваться метрика WER (Word Error Rate), основанная на расстоянии Левенштейна. , где S — количество замен, D — количество ударений, I — количество вставок, а N — количество слов во референсной транскрипции В задаче оценки генерации текста с помощью автокодировщика используются метрики Rouge-1, Rouge-L и BLEU. Расчёт Rouge-1 производится, согласно следующим формулам: , где в числителе — количество общих юниграмм в референсном тексте и в полученном, а в знаменателе — количество юниграмм в референсном тексте , где в числителе — количество общих юниграмм в референсном тексте и в полученном, а в знаменателе — количество юниграмм в сгенерированном тексте Расчёт Rouge-L производится, согласно следующим формулам: , где ДОП — длиннейшая общая подпоследовательность Расчёт BLEU [7] производится, согласно следующим формулам: , где c — длина сгенерированного текста, r — «эффективная» длина референсного текста  - вес для данной n-граммы  , где Count — количестве слов в n-грамме MaxRefCount — максимальное количество слов в референсной транскрипции
        len(DocSection.structure): 0 DocSection.name: 3.1.3 Предобработка аудиоданных lvl: 4
        Зачастую, работать напрямую с аудиосигналом неудобно — это приводит обработке очень длинных последовательностей, что усложняет вычисления. Кроме того, представление в виде сырого аудиосигнала может быть не очень инфомативным в задаче распознавания речи. Одним из самых распространённых представлений аудиосигнала является лог-мел-спектрограмма. Спектограмма — это визуальное представление зависимости спектральной плотности мощности сигнала от времени, получаемое с помощью оконного преобразования Фурье. Пример такого представления можно видеть на рис. 4. Формула для расчёта интенстивности: , где t — время w — частота stft — оконное преобразование Фурье Рисунок 4 – Спектрограмма Лог-спектрограмма — это спектрограмма, значения интенсивности которой отложены в децибелах. Пример такой спектрограммы можно видеть на рис. 5. Рисунок 5 – Лог-спектрограмма Лог-мел-спектрограмма — это лог-спектрограмма, частоты которой преобразованы специальным образом. Мел-шкала создана в связи с тем, что люди нелинейно воспринимают разницу между частотами в разных диапазонах. Для перевода значений в мел-шкалу используется следующая формула: Пример такой спектрограммы можно видеть на рис. 6. Рисунок 6 – Лог-мел-спектрограмма
      len(DocSection.structure): 0 DocSection.name: 3.2 Спектральные аугментации (SpecAug) lvl: 3
      Одним из самых простых и эффективных способов аугментации спектрограмм являются спектральные аугментации [26]. Пусть у нас есть спектрограмм в границах по оси времени и по оси частоты, тогда спектральная аугментация это процесс в ходе которого выделяется случай отрезов спектрограммы по одной из осей и удаляется. Рисунок 7 – Пример результата применения спектральных аугментаций На рис. 7 можно чётко видеть «вырезанные» области прямоугольного цвета, которые были заполнены нулями. Аугментации такого типа не позволяют моделям переобучаться на те или иные частоты и делают их более устойчивыми к кратковременным помехам или потерям сигнала.
      len(DocSection.structure): 2 DocSection.name: 3.3 Диффузионные модели lvl: 3
      Диффузионные модели — это класс моделей скрытых переменных, которые обучаются итеративно преобразовывать случайный Гауссовский шум, который может быть сгенерирован аналитически, в наблюдения из данных с неизвестным распределением. Этот класс моделей был впервые предложен в статье в 2015 году [8]
        len(DocSection.structure): 0 DocSection.name: 3.3.1 Прямой процесс диффузии lvl: 4
        Прямой процесс диффузии — процесс зашумления исходного наблюдения с помощью добавление нормального шума. Данный алгоритм получает на вход некое наблюдение из реальных данных - , после чего начинается добавлять небольше количество нормального шума. После повторения такой операции T раз получается последовательносить замушлённых наблюдений . Добавление шума параметризовано с помощью коэффициентов . В ходе такого процесса исходное наблюдение  с каждым шагом теряет всё больше данных и содержит всё меньше информации об исходном объекте. Причём для вычисления зашумлённого x на произвольном шаге не требуется вычислять все промежуточные шаги так как легко можно репараметризовать формулу, введя обозначения  и
        len(DocSection.structure): 0 DocSection.name: 3.3.2 Обратный процесс диффузии lvl: 4
        Обратный процесс диффузии — процесс восстановление исходного наблюдений по его зашумлённому состоянию. Для построения точной оценки  требуется весь набор данных, что является трудновыполнимым условием, поэтому для этой задачи обучается модель , способная аппроксимировать эти условные вероятности и запустить обратный процесс диффузии.  Для этого нужно обучить модель для предсказания  Однако значение известно нам на обучении, поэтому можно предсказывать 
сразу добавленный шум . В статье [ссылка на папиру про упрощения лосса] эмпирически обнаружено, что диффузионные модели лучше работают при обучении с лоссом:
      len(DocSection.structure): 0 DocSection.name: 3.4 Архитектура трансформер lvl: 3
      Трансформер — одна из самых популярных архитектур нейронных сетей, основанная на muti-head self-attention, была предложена в статье 2017 года [9]. Трансформер состоит из двух больших блоков, которые идентичны между собой — энкодер и декодер. Разница лишь в аттеншен маска т.е к каким токенам имеется доступ при вычислении multi-head self-attention. Энкодер и декодер состоят, в свою очередь, из multi-head self-attention и небольших сетей прямого распространения, пример блока изображён на рис. 8. Рисунок 8 – Высокоуровневое представление одного трансформер-блока Здесь - эмбеддинги элементов последовательности, которую обрабатывает трансформер. На первом слое такие эмбеддинги берутся из специального словаря, который хранит споставления (уникальный элемент, его эмбеддинг), а далее такие эмбеддинги получаются в ходе работыть предыдущих трансформер-блоков. Внутри multi-head self-attenion есть три матрицы проекций: Query (запросы) Key (ключи) Values (значения) По входному эмбеддингу вычисляются его query, key и value с помощью этих матриц проекций. Далее query вектора каждого элемента умножаются на каждый элемент key векторов каждого элемента, в результате чего получается некий «вес», который каждый элемент присваивает всем остальным элементам. После эти веса нормируются и используются для взвешенной суммы value векторов, которые становятся новыми эмбеддингами. В матричном виде эти преобразования можно записать следующим образом: , где Q — значения query векторов K — значения key векторов V — значения value векторов d — внутрення размерность модели Причем таких наборов матриц проекций строится несколько, каждый такой набор называется «головой» self-attention
      len(DocSection.structure): 0 DocSection.name: 3.5 Автокодировщик lvl: 3
      Автокодировщик  – класс искуственных нейронных сетей, который используется для получения оптимальных векторных представлений каких-либо данных, предложенный в [4]. Архитектура таких моделей выглядит следующим образом         : Энкодер — нейронная сеть, которая получает на вход данные в исходном пространстве и выполняет ряд преобразований, в результате которых получает новое представление данных в латентном пространстве, размерность которого существенно меньше размерности представления в исходном пространстве Декодер — нейронная сеть, которая получает на вход векторное представление из латентного пространства и восстанавливает исходный объект в исходном пространстве Изображение архитектуры в общем виде можно видеть на рис. 9. Рисунок 9 – Общий вид архитектуры автокодировщика Для обучения таких моделей требуется ввести лосс функцию реконструкции, например, среднеквадратичную ошибку между входным вектором и результатом работы декодера то есть результатом восстановления наблюдения из полученного латентного представления.
      len(DocSection.structure): 0 DocSection.name: 3.6 Latent Diffusion for Language Generation lvl: 3
      В этой статье [21] авторы обучают текстовую диффузию для задачи генерации текста. Для этого они используют несколько предобученных sequence-to-sequence моделей (BART и T5). Предлагаемый метод состоит из двух основных частей: 1. Расширяют преодбученную языковую модель для получения автокодировщика текста  2. Предлагают модели непрерывной диффузии, которые обучаются генерировать текста на основе латентного распределения автокодировщиков Полученный метод представлен на рис. 10. Рисунок 10 – Визуализация архитектуры автокодировщика из статьи Latent Diffusion for Language Generation
      len(DocSection.structure): 1 DocSection.name: 3.6.1 Обучение автокодировщика lvl: 3
      На первом этапе авторы обучает автокодировщик на основе языковой модели, построенной с помощью архитектуру трансформер. Эксперименты проводятся с двумя моделями — BART-base [5], обученной командой исследователей из Facebook AI и FLAN-T5-base [6], обученной командой исследователей из Google.  Обе модели основаны на архитектуре трансформер, а значит содержат, как и большинство нейронных сетей, энкодер и декодер. В обычном сценарии работы векторные представления энкодера передаются в декодер, который, на их основе, генерирует новый текст. Авторы, с целью получения латентного пространства, добавляют между энкодером и декодером две нейросети — нейросеть сжатия и нейросеть реконструкции. Нейросеть сжатия получает на вход векторные представления данных из энкодера, после чего сжимает их. Один слой нейросети сжатия состоит из двух блоков — мультиголового механизма самовнимания и сети прямого распространения. Архитекутра сети изображена на рис. 11. Рисунок 11 – Архитектура нейросети сжатия (compression network). E(w) — векторные представления, полученные из энкодера, Z — обучаемые query вектора. MHA — мультиголовый механизм самовнимания, FF — сеть прямого распространения Архитектура нейросети реконструкции совпадает с архитектурой с сети сжатия с точность до размерности матриц так как проекция осуществляется в обратную сторону, из латентного пространства в пространство векторных представлений языковой модели Обучение моделей сжатия и реконструкции происходит по следующему алгоритму: 1) Полученный текст токенизируется 2) Токенизированный текст поступает на вход в энкодер, который генерирует векторные 
представления 3) Векторное представления поступают в сеть сжатия, где переводятся в латентное пространства 4) Латенты поступают в сеть реконструкции, где переводятся в исходные векторное представления и поступают в декодер 5) Декодер, на основе полученных представлений генерирует вероятностное распределение над токенами 6) Зная исходный текст, рассчитывается лосс-функция от исходного текста и полученных распределений. В качестве лосс-функции используется кросс-энтропия 7) С помощью градиентных метод оптимизации веса нейросетей сжатия и реконструкции обновляются. Веса энкодера и декодера в ходе обучение заморожены то есть не изменяются
        len(DocSection.structure): 0 DocSection.name: 3.6.2 Обучение диффузионной модели lvl: 4
        Входе первого этапа авторы получают автокодировщик, который умеет  генерировать латентные представления для текста фиксированного. На втором этапе авторы переходят к обучению диффузионной модели. Для набора текстовых данных 
авторы строят латентные представления, используя полученный автокодировщик. Для этого они обучают предиктор шума  для восстановления исходного x, с использованием среднеквадратичной ошибки в качестве лосс-функции: ,  где x — обучающие данные, t — временной шаг, - случайный Гауссовский шум, - означает расписание добавляемого шума, - зависящий от времене коэффициент взвешивания Для генерации текста авторы генерируют случайный латентный вектор из стандартного нормального распределения и запускают процесс обратной диффузии используют полученный вектор в качестве  При обучении авторы используют косинусное расписание добавляемых коэффициентов: При генерации авторы используют стандартное DDPM [20] расписание и делают 250 временных шагов. В качестве архитектуры предиктора шума используют трансформер с леернормами перед мультиголовыми механизмами внимания с 12 слоями и внутренней размерностью эмбеддингов 768.
      len(DocSection.structure): 2 DocSection.name: 3.7 wav2vec 2.0: A Framework for Self-Supervised Learning of Speech Representations lvl: 3
      В данной работе [23] авторы обучают модель для извлечения эмбеддингов из аудио, содержащих речь, которую затем дообучают на задачу распознавания речи.
        len(DocSection.structure): 0 DocSection.name: 3.7.1 Архитектура lvl: 4
        Рисунок 12 – Архитектура wav2vec 2.0 Модель состоит из трёх основных элементов: 1. Фича-энкодер - нейросеть для извлечения первичных признаков из аудио и понижения размерности. Состоит из нескольких свёрточных слоёв по оси времени, а также леернормов между ними и функций активации GELU. Ожидается, что аудио нормализовано и имеет среднее 0 и дисперсию 1. 2. Нейросеть контекста, которая получает эмбеддинги из фича-энкодера и строит более высокоуровневые 
эмбеддинги. Архитекутра этой нейросети основывается на трансформере, для кодирования позиционной информации используются свёрточные блоки, похожие на [17], после которых идёт GELU и леернорм 3. Модуль квантизации, который дискритизирует выходы фича-энкодера. Для квантизации создаётся G кодбуков с V эмбеддингами. Далее из каждого кодбука берётся по эмббедингу, они объединются и подаются в линейный слой. Для сохранения дифференцируемости этой операции используются софтмакс Гумбеля [18] Общий вид архитектуры изображён на рис. 12.
        len(DocSection.structure): 0 DocSection.name: 3.7.1 Обучение lvl: 4
        Фича-энкодер получает на вход исходное аудио X, и на выходе генерирует набор из  представление, где T — количество временных отрезков. Далее представления, полученные из фича-энкодера передаются в нейросеть контекста, которая генерирует новые векторные эмбеддинги и используются далее при расчёте лосс функция. Для обучения модели в режиме без учителя то есть в отсутствии разметки авторы используют маскирование. Целью обучения является определение правильного квантованного представления звука среди набора таких представлений. Итоговая лосс функция состоит из двух компонент:  Первая компонента - - отвечает за правильность классификации квантизованного представления: , где - множество возможноых квантизованных представлений - замаскированное квантизованное представление - векторое представление, полученное из модели - косинусная близость  Вторая компонента - , так называемая лосс-функция разнообразия и отвечает за увеличения использования представлений из кодбуков. Авторы определяют её как задачу максимазации средней энтропии вероятностного распределения над векторами кодбука:
      len(DocSection.structure): 0 DocSection.name: 3.8 Предлагаемый подход lvl: 3
      Рассмотрев все вышеизложенные публикации можно перейти к описанию подхода, предлагаемого в данной работе. Текстовая диффузия с обуславливанием на аудиоэмбеддинги уже была представлена в работе TransFusion, однако там использовалась мультиноминальная диффузия т.е диффузия на уровне вероятностного распределения. В то время, как последний публикации в областе диффузионных моделей показывают, что намного эффективней использовать диффузионные модели, действиющие в латентных пространствах.
      len(DocSection.structure): 0 DocSection.name: 3.8.1 Обучение автокодировщика lvl: 3
      Для обучения диффузионной модели требуется создать автокодировщик текста, в латентном пространстве которого будет работать модель. Подходящий автокодировщик уже был разобран выше при рассмотрении статьи Latent Diffusion for Language Generation. Осталось лишь обучить такой автокодировщик на домене транскрипций. Основной для обучения автокодировщика послужит модель от компании Facebook AI — BART-base.
      len(DocSection.structure): 1 DocSection.name: 3.8.2 Получение эмбеддингов для аудио lvl: 3
      На данный момент, одной из лучших и популярнейших моделей в области получения эмбеддингов является предобученный wav2vec2.0 от компании Facebook AI, архитектура и принцип работы которого также рассмотрены выше. В данной работе используется версия wav2vec2.0-large.
        len(DocSection.structure): 0 DocSection.name: 3.8.3 Обучение диффузионной модели lvl: 4
        В качестве архитекутры предсказателя шума был выбран трансформер с пре-леернормами (то есть нормировка производится перед механизмом внимания), что позволяет улучшить стабильность и сходимость модели. Для построения эмбеддингов временного шага используются синусоидальные абсолютные эмбеддинги: Для кодирования позиционной информации аудио эмбеддингов используется относительный позиционный кодировщик, основанный на обучаемых свёртках. В качестве лосс-функции используется среднеквадратичная ошибка между шумом, добавленным в ходе прямого процесса диффузии и шумом предсказанным в ходе обратного на каждой итерации. На обучении используется DDPM расписание добавления шума c 200 временных шагов.
    len(DocSection.structure): 3 DocSection.name: 4. Практическая часть lvl: 2

      len(DocSection.structure): 0 DocSection.name: 4.1 Используемые инструменты и библиотеки lvl: 3
      Для написания кода и последующего проведения экспериментов был использован ряд фреймворков и библиотеки: PyTorch — самый популярный фреймворк для глубокого обучения, который содержит в себе абстракции для тензорных вычислений, автоматического дифференцирования, вычислений на CUDA и ряд реализаций типовых слоёв нейронных сетей и многое другое [11]. Transformers — фреймворк для глубокого обучения, разработанный компанией huggingface, содержащий большое количество реализаций современных архитектур нейронных сетей и предобученных моделей, основанных на архитектуре трансформер [12]. Diffusers — фреймворк для глубокого обучения, разработанный компанией huggingface, содержащий большое количество реализаций современных архитектур нейронных сетей и предобученных моделей, основанных на диффузионных моделях [13]. Accelerate — фреймворк для ускорения обучения нейронных сетей, разработанный компанией huggingface, содержит ряд абстракций для упрощения обучения в DistriburedDataParallel (параллелизм по графическим процессорам) режиме, облегчает работу с перемещением данных между оперативной памятью и памятью графического процессов, оптимизирует вычисления [14].
      len(DocSection.structure): 0 DocSection.name: 4.2 Описание данных lvl: 3
      В рамках данной работы был использован корпус данных LibriSpeech-960h [10], который содержит 960 часов размеченной английской речи из аудиокниг для обучения,  большая часть книг взята из проекта «Гутенберг». Также в корпусе есть несколько валидационных сетов, которые разделены на две категории - «чистые» и «прочие», в зависимости от качества условий записи. Каждый из валидационных сетов содержит примерно 5 часов человеческой речи. Исходные аудио представлены в формате .flac c частотой 16 килогерц в виде моноканальных канальных записей.
      len(DocSection.structure): 4 DocSection.name: 4.3 Описание экспериментов lvl: 3
      Эксперименты проводились на 8 графических процессорах NVIDIA A100-PCIE-40GB. Обучение происходило на датасете LibriSpeech-960h. Для обучения автокодировщика использовались референсные транскрипции, а для обучения диффузионной 
модели эмбеддинги аудио из wav2vec2.0-large и эмбеддинги текста из обученного автокодировщика.
        len(DocSection.structure): 0 DocSection.name: 4.3.1 Обучение автокодировщика текста lvl: 4
        Был проведён ряд экспериментов по обучению автокодировщика текста с различными параметрами.  Параметры при обучении нейросети сжатия: 3 скрытых слоя Оптимизатор AdamW с  бетами (0.9, 0.999) Линейное расписание коэффциентов обучения Размер батча 365 Общее количество итераций 50000 Количество итераций разгогрева  1000 Пиковое значение коэффициента обучение 1e-5 Параметры при обучении нейросети реконструкции:  3 скрытых слоя Оптимизатор AdamW с бетами (0.9, 0.999) Линейное расписание коэффциентов обучения Размер батча 365 Общее количество итераций 50000 Количество итераций разгогрева  1000 Пиковое значение коэффициента обучение 1e-5 В качестве предобученной языковой модели использовался BART-base от компании Facebook AI. Результаты экспериментов представлены в таблице 1. Таблица 1 – значение метрик для автокодировщика
        len(DocSection.structure): 0 DocSection.name: 4.3.2 Получение векторных представлений аудио lvl: 4
        Для получения векторых представлений использовалась модель wav2vec2.0-large от компании Facebook AI.
        len(DocSection.structure): 0 DocSection.name: 4.3.3 Обучение предсказателя шума lvl: 4
        После получения аудиоэмбеддингов и обучения автокодировщиках становится возможным обучить диффузионную модель.  На вход модель получает текущее латентное представление текста, аудиоэмбеддинг и номер шага диффузии.   Архитектура представляет собой трансформер с пре-леернормами и кросс-аттеншеном на части слоёв между внутренними представлениями сети и аудиоэмбеддингами. Для эмбеддингов аудио используются обучаемые относительные позиционные эмбеддинги из 
[17] с параметрами conv_pos = 32, conv_pos_groups = 4. Для эмбеддингов аудио используются абсолютные синусоидальные эмбеддинги с параметрами t_emb_dim = 768, t_emb_max_period = 1000. По полученным эмбеддингам и информации о временном шаге диффузии модель предсказывает шум.  Исходя из значений предсказаний и истинных значений добавленного шума расчитывается среднеквадратичная ошибка, а далее происходит минимизация данной ошибки.  Параметры обучения: 24 трансформер-блока Оптимизатор AdamW с бетами (0.9, 0.999) Линейное расписание коэффициентов обучения Размер батча 500 Общее количество итераций 700k Количество итераций разгогрева  30000 Пиковое значение коэффициента обучения 3e-5
        len(DocSection.structure): 0 DocSection.name: 4.3.4 Оценка и сравнения полученной модели lvl: 4
        Оценка проводилась на валидационных датасетах из корпуса LibriSpeech, значение метрик для TransFusion и Conformer были взяты из статей.  Результаты экспериментов представлены в таблице 2. Таблица 2 – значение WER на валидационных датасетах Результаты для Conformer указаны с учётом применения языковой модели для последующей переоценки возможных транскрипций. Для объяснения причин таких низких метрик можно рассмотреть кривые обучения. Рисунок 13 – График лосс функции на обучении предиктора шума Рисунок 14 – График метрики rougeLsum на валидацци при обучении автокодировщика Исходя из графика на рис. 13 можно сделать вывод о том, что автокодировщик хорошо выполняет задачу восстановления и почти не теряет данные, однако это ничего не говорит об организации его латентного пространства. Вместе с тем на рис. 14 видно, что при обучении предиктора шума лосс-функции быстро выходит на плато на уровне 0.2 и начинает там осциллировать, также видно, что кривая лосс-функции довольно шумная. Так как процесс диффузии происходит в латеном пространстве автокодировщика можно сделать вывод о том, что оно устроено слишком сложно и предиктор шума не может достаточно хорошо оценить добавленный шум.
    len(DocSection.structure): 4 DocSection.name: 5. Обеспечение качества разработки, продукции, программного продукта lvl: 2

      len(DocSection.structure): 0 DocSection.name: 5.1 Определение потребителей lvl: 3
      Потребителями разработанной модели могут быть: Компании, разрабатывающие системы видеоконфенцсвязи, использующие системы распознавания речи для транскрибации прошедших встреч Компании, разрабатывающие системы речевой аналитики, использующие системы распознавания речи для транскрибации звонков и последующего анализа текстов  Компании, разрабатывающие голосовых помощников, использующие системы распознавания речи для распознавания команд и запросов пользователя
      len(DocSection.structure): 0 DocSection.name: 5.2 Функции продукции lvl: 3
      Для того, чтобы ответить на вопрос, какие функции имеет, разработанный продукт, необходимо ввести определение функции изделия или услуги. Функции изделия или услуги – это требования и ожидания потребителя, которые могут быть установлены, предполагаются или являются обязательными. Перечень пользовательских требования к разработанной системе: Пользователь должен получать результат распознавания речи Пользователю должна предоставляться оценка качества модели по метрике WER на размеченных данных
      len(DocSection.structure): 0 DocSection.name: 5.3 Качество и характеристики lvl: 3
      Для обеспечения качества разрабатываемой системы был проведен обзор стандартов, протоколов, отраслевых требований и современных лучших практик, нужных в разработке. При этом качество – степень соответствия совокупности присущих характеристик объекта требованиям (согласно ГОСТ Р ИСО 9000-2015). Знание протоколов, стандартов и пр. позволяет обеспечить соответсвие системы современным требования, повысить эффективность и удобство использования. Анализ функциональных требований к разработке отражён в таблице 3. Таблица 3 – функциональные требования
      len(DocSection.structure): 0 DocSection.name: 5.4 Измерение характеристик качества. Операциональное определение lvl: 3
      Операциональное определение (ОО) – это уточнение значения того или иного термина применительно к данной системе, находящейся в конкретных условиях и для людей, в ней задействованных. ОО необходим для уменьшения случаев разночтения и неоднозначности при общении между людьми, задействованными в системе, а также для более точного определения целей и задач, которые необходимо достичь. ОО должно содержать как минимум три компоненты: Требования или стандарт, относительно которого оценивается результат измерения или испытания (критерий). Метод испытания или процедура измерения свойства объекта (тест) Процедура принятия решения (анализ), которое показывает, соответствует ли результат испытания стандарту. Операциональные определения для разработанной модели описаны в таблице 4. По итогам рассмотрения оперциональных опеределений было установлена, что разработанная модель не удовлетворяет описанным требования, однако существует ряд предложений по улучшению, сформированных в таблице 5 Таблица 5 — предложения по улучшению модели.
    len(DocSection.structure): 0 DocSection.name: ЗАКЛЮЧЕНИЕ lvl: 2
    В рамках данной работы был проведён анализ существующих решений, рассмотрен подход к диффузионным моделям в задаче распознавания речи из статьи TransFusion. Далее были изучены актуальные методы для генерации текста с помощью текстовой диффузии и её обуславливания на информацию из аудио. После выбора метода была реализована диффузионная модель для генерации текста на основе аудиоэмбеддинга. Данная модель использует текстовый автокодировщик для получения латентных представлений текста, которые используются в диффузии. Для полученной модели была проведена оценка качества и сравнение с аналогами на основе валидационных датасетов из корпуса LibriSpeech-960h В результате работы была провена гипотеза о применимости диффузионных моделей на непрерывных представлениях в задаче распознавания речи. Результатом проверки гипотезы стал вывод о неприменимости данного подхода из-за плохого качества.  Для улучшения качества имеет смысл используются другие способы получения латентного пространства, такие как вариационный автоэнкодер или flow-matching.