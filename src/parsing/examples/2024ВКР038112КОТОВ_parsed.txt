Doc.name: РАЗРАБОТКА МОДЕЛИ КЛАССИФИКАЦИИ СОБЫТИЙ В ЖУРНАЛАХ ВЕБ-СЕРВЕРОВ
Doc.author: Котов Д.А.
Doc.academic_supervisor: Заславский М.М.
Doc.year: 2024
len(Doc.structure): 4 Doc.name: РАЗРАБОТКА МОДЕЛИ КЛАССИФИКАЦИИ СОБЫТИЙ В ЖУРНАЛАХ ВЕБ-СЕРВЕРОВ
    len(DocSection.structure): 0 DocSection.name: ОПРЕДЕЛЕНИЯ, ОБОЗНАЧЕНИЯ И СОКРАЩЕНИЯ lvl: 2
    ЯП – язык программирования; IDE – Integrated Development Environment; ПО – программное обеспечение; HTTP – HyperText Transfer Protocol; HTML – HyperText Markup Language; URL – Uniform Resource Locator; CLF – Common Log Format; DBSCAN – Density-Based Spatial Clustering of Applications with Noise; BERT – Bidirectional Encoder Representations from Transformers; Лог - файл журнала с записями о событиях в хронологическом порядке.
    len(DocSection.structure): 0 DocSection.name: ВВЕДЕНИЕ lvl: 2
    С каждым днем количество веб-серверов и их пользователей растет [1]. В связи с этим возникает необходимость в эффективном анализе и обработке данных журналов событий веб-серверов для обеспечения надежности и безопасности веб-сервисов, а также для выявления и предотвращения возможных аномалий. Цель данной работы разработка модели классификации событий в журналах веб-серверов на основе методов машинного обучения. Задачи данной работы: Изучение и анализ существующих алгоритмов кластеризации. Разработка алгоритма предварительной обработки данных журналов для повышения эффективности классификации.  Создание и обучение модели классификации событий.  Оценка эффективности разработанной модели на реальных данных. Объектом исследования является модель для классификации журналов веб серверов.  Предметом исследования является алгоритм кластеризации и выявления аномалий. Практическая значимость работы заключается в том, что разработанная модель классификации событий в журналах веб-серверов способствует автоматизации процессов обнаружения аномалий, что позволяет сократить время на обработку инцидентов.
len(DocSection.structure): 5 DocSection.name: Структура lvl: None

    len(DocSection.structure): 2 DocSection.name: 1 ОБЗОР ПРЕДМЕТНОЙ ОБЛАСТИ lvl: 2

      len(DocSection.structure): 4 DocSection.name: 1.1 Основные теоретические положения  lvl: 3

        len(DocSection.structure): 0 DocSection.name: 1.1.1 Работа веб-сервера  lvl: 4
        Веб-сервер — это ПО, обрабатывающее запросы к веб-страницам через Интернет и предоставляющее HTTP-ответы, как правило, вместе с HTML-страницей, изображением, файлом, медиа-потоком или другими данными. Он работает по следующему принципу: Получение запроса: Когда пользователь вводит URL веб-сайта в браузере или переходит по ссылке, браузер отправляет запрос на веб-сервер, на котором хранится сайт. Обработка запроса: Веб-сервер анализирует полученный запрос, определяя, какую страницу или ресурс (например, изображение или документ) необходимо предоставить. Поиск ресурса: Веб-сервер ищет запрашиваемый ресурс на своем хранилище. Если ресурс требует дополнительной обработки (например, выполнения скриптов на стороне сервера), сервер выполняет необходимые действия для генерации финального содержимого. Отправка ответа: После нахождения или генерации запрашиваемого ресурса, веб-сервер формирует ответ, который включает в себя статус (например, успешно или ошибка) и сам ресурс (HTML-страницу, изображение и т.д.). Отображение ресурса: Браузер пользователя получает ответ от веб-сервера, обрабатывает его и отображает содержимое страницы или сообщение об ошибке, если доступ к ресурсу не был получен. Схема работы сервера изображена на рис. 1. Рисунок 1 — Схема работы веб-сервера
        len(DocSection.structure): 0 DocSection.name: 1.1.2 Запросы к серверу lvl: 4
        В протоколе HTTP предусмотрено большое количество методов с помощью которых можно совершать запросы. Но в повседневной практике используется, как правило только три: GET, POST и HEAD, именно они и встречаются в наборе данных, который использовался для анализа событий журнала веб-сервера. Ниже представлено краткое пояснение к запросам к веб-серверу( таблица 1). Таблица 1 — Запросы к веб-серверу
        len(DocSection.structure): 0 DocSection.name: 1.1.3 Коды ответа HTTP lvl: 4
        Коды ответа HTTP — это стандартизированные коды, которые веб-серверы используют для сообщения клиентам о результате их запросов. Коды ответа подразделяются на несколько классов, каждый из которых имеет свою сферу применения. Ниже представлено краткое пояснение к кодам ответа HTTP( таблица 2). Таблица 2 — Коды ответа HTTP.
        len(DocSection.structure): 0 DocSection.name: 1.1.4 Логи сервера Apache lvl: 4
        Логи сервера Apache — это файлы журналов, в которые записывается информация о всех запросах и действиях, происходящих на веб-сервере. Эти данные крайне важны для анализа трафика, отладки, мониторинга безопасности и оптимизации работы сервера. Основные типы лог-файлов Apache: Access Log (Журнал доступа): Содержит информацию о каждом запросе к серверу. Здесь можно найти данные о времени запроса, IP-адресе клиента, методе HTTP, запрашиваемом URL, статусе 
HTTP ответа, размере ответа и информацию о браузере пользователя (User-Agent). Error Log (Журнал ошибок): Фиксирует ошибки, возникшие во время работы сервера. Это могут быть проблемы с конфигурацией, недоступность файлов, проблемы с сетевыми соединениями и другие системные ошибки. Этот журнал является основным инструментом для диагностики проблем на сервере. Custom Logs (Пользовательские журналы): Apache позволяет настраивать логи для записи специфической информации в соответствии с потребностями администратора. Это может быть полезно для сбора конкретных данных для анализа. Однако в данной работе для анализа журналов событий используется только Access Log. В записи логов сервера Apache 
используется формат Common Log Format (CLF)[4] или его расширения, такие как Combined Log Format. Пример стандартной записи в Access Log в формате CLF изображён на рис. 2 Рисунок 2 — Пример записи логов веб-сервера В логах содержится следующая информация: IP адрес устройства с которого совершен запрос; Дата и время запроса; URL адрес к которому направлен запрос; Метод с помощью которого совершен запрос (GET, POST и т. д); Код ответа на совершенный запрос; Referer — адрес страницы с которой был совершен переход на текущую; User-Agent пользователя — идентификатор устройства и браузера. С помощью логов мы можем выявить множество метрик: На какие страницы чаще всего заходят пользователи; С каких устройств чаше всего заходят пользователи; Какие поисковые боты посещают сайт и какие страницы индексируют; Наличие на сайте несуществующих страниц, к которым тем не менее обращаются пользователи и, что наиболее важно поисковые боты; Наличие на сайте редиректов; Наличие на сайте критических ошибок 5xx.
      len(DocSection.structure): 7 DocSection.name: 1.2 Кластеризация объектов или кластерный анализ lvl: 3

        len(DocSection.structure): 0 DocSection.name: 1.2.1 Понятие кластеризации lvl: 4
        Кластеризация (или кластерный анализ)[2]  представляет собой процесс группировки набора элементов в группы, называемые кластерами. Целью является собрать в одной группе элементы, которые между собой похожи, в то время как элементы, принадлежащие к разным группам, должны максимально отличаться друг от друга. Основное различие между кластеризацией и классификацией заключается в том, что при кластеризации заранее не определены конкретные группы, их выявление происходит в ходе выполнения алгоритма. Процесс кластерного анализа включает в себя несколько шагов: Выборка данных для кластеризации. Определение набора переменных, по которым будет проводиться оценка элементов выборки. При необходимости осуществляется нормализация данных. Расчет значений меры сходства между элементами. Применение специализированного метода кластерного анализа для формирования групп похожих элементов(кластеров). Визуализация и интерпретация полученных результатов кластеризации. На этапе анализа результатов может потребоваться доработка используемых метрик и методов кластеризации для достижения наилучших результатов.
        len(DocSection.structure): 0 DocSection.name: 1.2.2 Меры расстояний lvl: 4
        Чтобы вычислять значения меры сходства между объектами  нужно составить вектор характеристик для каждого объекта — как правило, это набор числовых значений. Однако существуют также алгоритмы, работающие с качественными (категорийными) характеристиками. После того, как определён вектор характеристик, можно провести нормализацию, чтобы все компоненты давали одинаковый вклад при расчете «расстояния». В процессе нормализации все значения приводятся к некоторому диапазону, например, или . Далее, для каждой пары объектов измеряется «расстояние» между ними — степень похожести. Существует множество метрик, чаще всего используются: Евклидово расстояние Наиболее распространенная функция расстояния. Представляет собой геометрическим расстоянием в многомерном пространстве: Квадрат евклидова расстояния Применяется для придания большего веса более отдаленным друг от друга объектам. Это расстояние вычисляется следующим образом: Расстояние городских кварталов (манхэттенское расстояние)[9] Это расстояние является средним разностей по координатам. В большинстве случаев эта мера расстояния приводит к таким же результатам, как и для обычного расстояния Евклида. Однако для этой меры влияние отдельных больших разностей (выбросов) уменьшается (т.к. они не возводятся в квадрат). Формула для расчета манхэттенского расстояния: Расстояние Чебышева Это расстояние может оказаться полезным, 
когда нужно определить два объекта как «различные», если они различаются по какой-либо одной координате. Расстояние Чебышева вычисляется по формуле: Степенное расстояние Применяется в случае, когда необходимо увеличить или уменьшить вес, относящийся к размерности, для которой соответствующие объекты сильно отличаются. Степенное расстояние вычисляется по следующей формуле: где  и  – параметры, определяемые пользователем. Параметр  ответственен за постепенное взвешивание разностей по отдельным координатам, параметр  ответственен за прогрессивное взвешивание больших расстояний между объектами. Если оба параметра –  и  — равны двум, то это расстояние совпадает с расстоянием Евклида. Выбор метрики полностью лежит на исследователе, поскольку результаты кластеризации могут существенно отличаться при использовании разных мер.
        len(DocSection.structure): 0 DocSection.name: 1.2.3 Классификация алгоритмов lvl: 4
        Иерархические и плоские. Иерархические алгоритмы (также называемые алгоритмами таксономии) строят не одно разбиение выборки на непересекающиеся кластеры, а систему вложенных разбиений. Таким образом на выходе получается дерево кластеров, корнем которого является вся выборка, а листьями — наиболее мелкие кластера. Плоские алгоритмы строят одно разбиение объектов на кластеры. Четкие и нечеткие. Четкие (или непересекающиеся) алгоритмы каждому объекту выборки ставят в соответствие номер кластера, таким образом каждый объект принадлежит только одному кластеру. Нечеткие (или пересекающиеся) алгоритмы каждому объекту ставят в соответствие набор вещественных значений, показывающих степень отношения объекта к кластерам. В итоге каждый объект относится к каждому кластеру с некоторой вероятностью.
        len(DocSection.structure): 0 DocSection.name: 1.2.4 Объединение кластеров lvl: 4
        В случае использования иерархических алгоритмов необходимо решить, как объединять между собой кластера, как вычислять «расстояния» между ними. Существует несколько метрик: Одиночная связь (расстояния ближайшего соседа) В этом методе расстояние между двумя кластерами определяется расстоянием между двумя наиболее близкими объектами (ближайшими соседями) в различных кластерах. Результирующие кластеры имеют тенденцию объединяться в цепочки. Полная связь (расстояние наиболее удаленных соседей) В этом методе расстояния между кластерами определяются наибольшим расстоянием между любыми двумя объектами в различных кластерах (т.е. наиболее удаленными соседями). Этот метод обычно работает очень хорошо, когда объекты происходят из отдельных групп. Если же кластеры имеют удлиненную форму или их естественный тип является «цепочечным», то этот метод непригоден. Невзвешенное попарное среднее В этом методе расстояние между 
двумя различными кластерами вычисляется как среднее расстояние между всеми парами объектов в них. Метод эффективен, когда объекты формируют различные группы, однако он работает одинаково хорошо и в случаях протяженных («цепочечного» типа) кластеров. Взвешенное попарное среднее Метод идентичен методу невзвешенного попарного среднего, за исключением того, что при вычислениях размер соответствующих кластеров (то есть число объектов, содержащихся в них) используется в качестве весового коэффициента. Поэтому данный метод должен быть использован, когда предполагаются неравные размеры кластеров. Невзвешенный центроидный метод В этом методе расстояние между двумя кластерами определяется как расстояние между их центрами тяжести. Взвешенный центроидный метод (медиана) Этот метод идентичен предыдущему, за исключением того, что при вычислениях используются веса для учета разницы между размерами кластеров. Поэтому, если имеются или подозреваются значительные отличия в размерах кластеров, этот метод оказывается предпочтительнее предыдущего.
        len(DocSection.structure): 0 DocSection.name: 1.2.5 Обзор алгоритмов кластеризации lvl: 4
        Алгоритмы иерархической кластеризации[5] Среди алгоритмов иерархической кластеризации выделяются два основных типа: восходящие и нисходящие алгоритмы. Нисходящие алгоритмы работают по принципу «сверху-вниз»: в начале все объекты помещаются в один кластер, который затем разбивается на все более мелкие кластеры. Более распространены восходящие алгоритмы, которые в начале работы помещают каждый объект в отдельный кластер, а затем объединяют кластеры во все более крупные, пока все объекты выборки не будут содержаться в одном кластере. Таким образом строится система вложенных разбиений. Результаты таких алгоритмов обычно представляют в виде дерева – дендрограммы. Классический пример такого дерева – классификация животных и растений. Для вычисления расстояний между кластерами чаще все пользуются двумя расстояниями: одиночной связью или полной связью . К недостатку иерархических алгоритмов можно отнести систему полных разбиений, которая может являться излишней в контексте решаемой задачи. Алгоритмы квадратичной ошибки[6] Задачу кластеризации можно рассматривать как построение оптимального разбиения объектов на группы. При этом оптимальность 
может быть определена как требование минимизации среднеквадратической ошибки разбиения: где  — «центр масс» кластера j (точка со средними значениями характеристик для данного кластера). Алгоритмы квадратичной ошибки относятся к типу плоских алгоритмов. Самым распространенным алгоритмом этой категории является метод k-средних. Этот алгоритм строит заданное число кластеров, расположенных как можно дальше друг от друга. Работа алгоритма делится на несколько этапов: Случайно выбрать k точек, являющихся начальными «центрами масс» кластеров. Отнести каждый объект к кластеру с ближайшим «центром масс». Пересчитать «центры масс» кластеров согласно их текущему составу. Если критерий остановки алгоритма не удовлетворен, вернуться к пункту 2. В качестве критерия остановки работы алгоритма обычно выбирают минимальное изменение среднеквадратической ошибки. Так же возможно останавливать работу алгоритма, если на шаге 2 не было объектов, переместившихся из кластера в кластер. К недостаткам данного алгоритма можно отнести необходимость задавать количество кластеров для разбиения. Нечеткие алгоритмы Наиболее популярным алгоритмом нечеткой кластеризации является алгоритм c-средних (c-means). Он представляет собой модификацию метода k-средних. Шаги работы алгоритма: Выбрать начальное нечеткое разбиение  объектов на  кластеров путем выбора матрицы принадлежности  размера . Используя матрицу , найти значение критерия нечеткой ошибки: , где  — «центр масс» нечеткого кластера : . Перегруппировать объекты с целью уменьшения этого значения критерия нечеткой ошибки. Возвращаться в пункт 2 до тех пор, пока изменения матрицы  не станут незначительными. Этот алгоритм может не подойти, если заранее неизвестно число кластеров, либо необходимо однозначно отнести каждый объект к одному кластеру. DBSCAN (Density-Based Spatial Clustering of Applications with 
Noise)[3] DBSCAN кластеризует точки, основываясь на их плотности расположения. Этот алгоритм способен находить кластеры произвольной формы и хорошо работает с данными, содержащими шум и выбросы. DBSCAN определяет кластеры как области высокой плотности, разделенные областями низкой плотности, и не требует предварительного определения количества кластеров. Этот алгоритм наиболее подходит для данной задачи, поскольку способен находить выбросы, в нашем случае аномалии, также не надо задавать количество кластеров заранее, алгоритм сам определяет их количество по данным. Алгоритмы, основанные на теории графов[7] Суть таких алгоритмов заключается в том, что выборка объектов представляется в виде графа , вершинам которого соответствуют объекты, а ребра имеют вес, равный «расстоянию» между объектами. Достоинством графовых алгоритмов кластеризации являются наглядность, относительная простота реализации и возможность внесения различных усовершенствований, основанные на геометрических соображениях. Основными алгоритмам являются алгоритм выделения связных компонент, алгоритм построения минимального покрывающего (остовного) дерева и алгоритм послойной кластеризации. Алгоритм выделения связных компонент В алгоритме выделения связных компонент задается входной параметр  и в графе удаляются все ребра, для которых «расстояния» больше . Соединенными остаются только наиболее близкие пары объектов. Смысл алгоритма заключается в том, чтобы подобрать такое значение , лежащее в диапазон всех «расстояний», при котором граф «развалится» на несколько связных компонент. Полученные компоненты и есть кластеры. Для подбора параметра  обычно строится гистограмма распределений попарных расстояний. В задачах с хорошо выраженной кластерной структурой данных на гистограмме будет два пика – один соответствует внутрикластерным расстояниям, второй – межкластерным расстояния. Параметр  подбирается из зоны минимума между этими пиками. При этом управлять количеством кластеров при помощи порога расстояния довольно затруднительно. Алгоритм минимального покрывающего дерева[8][10] Алгоритм минимального покрывающего дерева сначала строит на графе минимальное покрывающее дерево, а затем последовательно удаляет ребра с наибольшим весом. На рисунке изображен пример минимального покрывающего дерева, полученного для девяти объектов(рис. 3). Рисунок 3 — Минимальное покрывающее дерево для девяти объектов Путём удаления связи, помеченной , с длиной равной 6 единицам (ребро с максимальным расстоянием), получаем два кластера:  и . Второй кластер в дальнейшем может быть разделён ещё на два кластера путём удаления ребра , которое имеет длину, равную  единицам. Послойная кластеризация Алгоритм послойной кластеризации основан на выделении связных компонент графа на некотором уровне расстояний между объектами (вершинами). Уровень расстояния задается порогом расстояния . Например, если расстояние между объектами  , то . Алгоритм послойной кластеризации формирует последовательность подграфов графа , которые отражают иерархические связи между кластерами: где  — граф на уровне , ,  – -ый порог расстояния,  – количество уровней иерархии,  – пустое множество ребер графа, получаемое при , , то есть граф объектов без ограничений на расстояние (длину ребер графа), поскольку . Посредством изменения порогов расстояния , где , возможно контролировать глубину иерархии получаемых кластеров. Таким образом, алгоритм послойной кластеризации способен создавать как плоское разбиение данных, так и иерархическое.
        len(DocSection.structure): 0 DocSection.name: 1.2.6 Сравнение алгоритмов lvl: 4
        В таблице представлена вычислительная сложность алгоритмов(таблица 3) Таблица 3 — Вычислительная сложность алгоритмов. В таблице представлено сравнение алгоритмов(таблица 4) Таблица 4 — Сравнительная таблица алгоритмов.     
        len(DocSection.structure): 0 DocSection.name: 1.2.7 Выводы lvl: 4
        Выбор алгоритма кластеризации DBSCAN для анализа событий в журналах веб-серверов обусловлен рядом его преимуществ перед другими алгоритмами. Во-первых, DBSCAN отлично подходит для выявления аномалий, так как он способен определить и исключить отдаленные точки, которые не принадлежат ни одному кластеру, рассматривая их как выбросы. Это особенно ценно в контексте безопасности веб-серверов, где такие аномалии могут указывать на нестандартное или подозрительное поведение. Также, DBSCAN не требует предварительного указания количества кластеров, что делает его гибким в работе с данными, структура которых заранее неизвестна. Это позволяет алгоритму адаптироваться к данным различной природы и выявлять скрытые структуры без необходимости их предварительного определения. Помимо этого, DBSCAN устойчив к шуму и способен выделять кластеры произвольной формы, что делает его применимым к разнообразным наборам данных, включая те, которые содержат сложные и пересекающиеся структуры. Кроме того, DBSCAN эффективен в вычислительном плане, особенно когда используется в сочетании со структурами данных индексации, что позволяет сократить время обработки даже больших объемов данных. Таким образом, DBSCAN является мощным инструментом для кластеризации данных журналов веб-серверов, обеспечивая высокое качество обнаружения аномалий и гибкость в работе с различными типами данных.
    len(DocSection.structure): 6 DocSection.name: 2 ВЫБОР МЕТОДА РЕШЕНИЯ lvl: 2

      len(DocSection.structure): 0 DocSection.name: 2.1 Постановка задачи lvl: 3
      Необходимо разработать модель для кластеризации логов веб-серверов с целью выявления аномальных событий. Модель должна быть способна обрабатывать и анализировать записи журналов веб-серверов, выделяя из них статистически значимые кластеры, характеризующие типичное поведение системы, а также идентифицировать отклонения от нормы, которые могут свидетельствовать о потенциальных угрозах или нештатных ситуациях.
      len(DocSection.structure): 0 DocSection.name: 2.2 Сбор и предобработка данных lvl: 3
      Необходимо организовать сбор данных из журналов веб-серверов, их очистку и нормализацию для последующего использования в модели кластеризации. Это включает удаление нерелевантной информации, преобразование текстовых данных в числовой формат и обработку пропущенных значений.
      len(DocSection.structure): 0 DocSection.name: 2.3 Исследование и выбор метода кластеризации lvl: 3
      Также необходимо было провести анализ существующих алгоритмов кластеризации для определения наиболее подходящего под задачи работы. Нужно учитывать способность алгоритма обрабатывать большие объемы данных, его устойчивость к шуму и способность выявлять аномалии.
      len(DocSection.structure): 0 DocSection.name: 2.4 Разработка модели lvl: 3
      Далее нужно разработать модель, которая будет принимать на вход записи журналов, обрабатывать их и формировать кластеры, представляющие типовые сценарии работы веб-сервера. Модель должна быть способна адаптироваться к изменениям в данных и обновлять кластеры со временем.
      len(DocSection.structure): 0 DocSection.name: 2.5 Выявление аномалий lvl: 3
      Необходимо интегрировать механизмы для определения и отслеживания аномальных событий, которые не соответствуют ни одному из существующих кластеров. Это включает разработку правил или использование статистических методов для выявления потенциальных угроз.
      len(DocSection.structure): 0 DocSection.name: 2.6 Тестирование и валидация модели  lvl: 3
      Необходимо провести проверку эффективности модели на тестовых и реальных данных, оценка точности кластеризации и способности модели к детектированию аномалий. В силу отсутствия заранее размеченных данных, оценка качества кластеризации и способности модели к детектированию аномалий будет иметь субъективный характер.
    len(DocSection.structure): 3 DocSection.name: 3 ОПИСАНИЕ МЕТОДА РЕШЕНИЯ lvl: 2

      len(DocSection.structure): 0 DocSection.name: 3.1 Генерация набора событий журнала веб-сереров lvl: 3
      В процессе разработки модели классификации событий в журналах веб-серверов возникла необходимость в создании набора данных для начальных этапов обучения модели. Из-за отсутствия доступа к реальным журналам веб-сервера было принято решение о генерации искусственного набора данных, соответствующего формату CLF. Для создания искусственных записей журнала была использована библиотека faker, предназначенная для генерации случайных данных в языке программирования Python. Эта библиотека позволила сформировать реалистичные IP-адреса и URL-адреса, имитируя потенциальные запросы пользователей к веб-серверу. Поле user-agent было сгенерировано на основе десяти различных заготовленных значений, которые отражали распространенные браузеры и операционные системы. Остальные поля журнала, такие как дата и время запроса, статус ответа сервера и размер передаваемого контента, также создавались случайным образом, обеспечивая разнообразие в генерируемом наборе данных. Каждая запись в журнале формировалась путем случайного выбора значений для каждого поля, соблюдая структуру и формат CLF. Однако в ходе последующего тестирования модели выявилось, что использование сгенерированных данных приводит к неудовлетворительным результатам. Модель, обученная на искусственных данных, не смогла адекватно справляться с задачей классификации и выявления аномалий при работе с реальными журналами веб-серверов. Анализ показал, что отсутствие реалистичных шаблонов поведения и взаимосвязей в сгенерированных данных не позволяло модели корректно обобщать информацию и выявлять значимые аномалии. В связи с этим было принято решение отказаться от использования искусственно сгенерированных данных и перейти к работе с реальными журналами веб-серверов, что позволило значительно улучшить качество и точность классификации модели.
      len(DocSection.structure): 0 DocSection.name: 3.2 Предварительная обработка данных lvl: 3
       Был проведён отбор необходимых данных из общего множества записей журнала и удаление тех полей, которые не несут значимой информации для анализа. В рамках предварительной обработки было решено оставить следующие поля, которые считаются наиболее важными для дальнейшего анализа и выявления аномалий: Коды ошибок (Status Codes): Позволяют определить успешность или неудачу запроса и являются ключевыми для выявления проблем на веб-сервере. Время запроса (Timestamp): Важно для анализа паттернов активности и идентификации нестандартного поведения, например, внезапных всплесков трафика. URL (Uniform Resource Locator): Адрес запрашиваемого ресурса может указывать на целевые страницы атак или на необычные пути доступа. User-Agent: Информация о браузере и операционной системе пользователя помогает выявить подозрительные или устаревшие клиенты, потенциально уязвимые для эксплуатации. ENDPOINT: Конкретный ресурс на сервере, к которому был выполнен запрос, может выявить необычные или подозрительные пути доступа. SIZE OF RESPONSE: Размер ответа сервера может указывать на необычно большие или маленькие ответы, что также может быть признаком аномалии. Выбор этих полей обусловлен тем, что статистическое отклонение по ним может служить индикатором аномального поведения. Например, нестандартный размер ответа сервера или неожиданный всплеск в определенные периоды времени может указывать на попытки взлома, DDoS-атаки или другие виды аномалий. Анализ кодов ошибок может выявить не только технические проблемы, но и целенаправленные атаки на веб-сервер. Таким образом, предварительная обработка данных заключается в исключении из рассмотрения нерелевантных полей и фокусировке внимания на тех атрибутах, которые могут предоставить наиболее ценную информацию для обнаружения и анализа аномальных событий. Это создает основу для более эффективной и целенаправленной работы модели кластеризации и классификации событий.
      len(DocSection.structure): 3 DocSection.name: 3.3 Описание алгоритма lvl: 3

        len(DocSection.structure): 0 DocSection.name: 3.3.1  DBSCAN lvl: 4
        Так как основной задачей является разработка модели для кластеризации с выявлением аномалий, для достижения поставленной цели был выбран алгоритм DBSCAN, который является одним из наиболее подходящих методов для работы с данными такого типа. Алгоритм DBSCAN начинает свою работу с выбора произвольной точки из набора данных и создания вокруг неё области с заданным радиусом, который называется эпсилон-окрестностью. Если в этой окрестности обнаруживается количество точек, превышающее или равное минимально заданному порогу (minPts), то исходная точка классифицируется как корневая, что служит сигналом к формированию нового кластера. Затем алгоритм переходит к поиску соседних точек. Если в эпсилон-окрестности точки находится меньше, чем minPts соседей, но среди них есть хотя бы одна корневая точка, эта точка помечается как пограничная. Пограничные точки не могут формировать новые кластеры, но могут быть частью уже существующих кластеров. Все оставшиеся точки, которые не подпадают под критерии корневых или пограничных, считаются выбросами. Они не включаются в кластеры и могут быть интерпретированы как аномалии или шум в данных. Когда две корневые точки оказываются в пределах эпсилон-окрестности друг от друга, они объединяются в один кластер. Это свойство позволяет кластерам формироваться и расти, поглощая новые корневые точки и их пограничные соседи. Пограничные точки присоединяются к тем кластерам, к которым принадлежат корневые точки в их окрестности. Таким образом, они служат своего рода мостом, связывающим близлежащие кластеры. Процесс кластеризации завершается, когда все точки данных либо включены в кластеры, либо классифицированы как выбросы, и не остаётся ни одной точки, которую можно было бы добавить к существующим кластерам. Это гарантирует, что каждая точка будет рассмотрена и получит своё место в общей структуре данных.
        len(DocSection.structure): 0 DocSection.name: 3.3.2  Векторизация TF-IDF lvl: 4
        Для преобразования текстовых полей журналов в числовые векторы, которые могут быть использованы в кластеризации DBSCAN, применяется метод TF-IDF. Этот метод векторизации оценивает важность слова в контексте документа относительно всего корпуса документов. Term Frequency (TF) измеряет частоту слова в документе, а Inverse Document Frequency (IDF) уменьшает вес слов, которые встречаются очень часто и поэтому могут быть менее информативными. Произведение TF и IDF дает веса словам, которые помогают выделить наиболее значимые термины для каждого документа. Векторизация TF-IDF была реализована с использованием библиотеки Scikit-learn[11], которая предоставляет инструменты для преобразования текстовых данных в формат, удобный для анализа. Полученные векторы TF-IDF затем использовались в качестве входных данных для алгоритма DBSCAN, позволяя модели эффективно кластеризовать записи журналов и выявлять аномалии на основе анализа текстового содержимого.
        len(DocSection.structure): 0 DocSection.name: 3.3.3  Векторизация BERT lvl: 4
                Также использовалась векторизация текстовых полей журналов веб-серверов с помощью модели BERT[12], которая была доработана на данных файлов журналов веб-серверов. В отличие от  TF-IDF, данная модель использует нейронную сеть, состоящую из множества слоев, также учитывает расположение слова в текстовом поле и выдаёт разные векторы для одного и того же слова в зависимости от контекста. Например для поля user-agent, модель BERT могла выделить кластеры по платформам, которые использовали пользователи, а также находила поисковых роботов, являющихся составной частью поисковой системы yandex.
    len(DocSection.structure): 2 DocSection.name: 4 АНАЛИЗ ПОЛУЧЕННОГО РЕШЕНИЯ lvl: 2

      len(DocSection.structure): 0 DocSection.name: 4.1 Анализ решения, используя генерируемые данные lvl: 3
      Использование сгенерированных данных для анализа решения предоставило начальное понимание работы модели кластеризации. Эти данные были созданы таким образом, чтобы имитировать различные типы событий в журналах веб-серверов, включая нормальные запросы и потенциальные аномалии. Однако при анализе результатов выяснилось, что модель, обученная и протестированная на таких данных, не обладает достаточной точностью разбиения на кластеры. При оценке точности кластеризации, проведенной на основе сгенерированных данных, столкнулись с субъективностью оценки. В отсутствие чётко определённых критериев и методов для точного выявления кластеров и аномалий, оценка эффективности модели не может быть полностью объективной. В частности, для генерируемых данных было замечено, что записи журналов веб-серверов группируются в 10 кластеров в зависимости от поля user-agent. Учитывая, что в искусственном наборе данных присутствует только 10 уникальных значений user-agent, такое разделение не отражает реальную сложность и многообразие поведения пользователей веб-сервера. Это наблюдение подтверждает, что кластеризация, основанная исключительно на ограниченном числе уникальных значений user-agent, не является оптимальной. Такой подход может привести к излишней генерализации и игнорированию других важных аспектов данных, таких как временные паттерны, коды состояния HTTP и размеры ответов, которые могут предоставить более глубокое понимание поведения системы и потенциальных угроз. Ниже представлена визуализация в трехмерном пространстве кластерного анализа искусственных данных, которые разбиты на 10 кластеров(рис. 4) Рисунок 4 — визуализация кластерного анализа искусственных данных
      len(DocSection.structure): 0 DocSection.name: 4.2 Анализ решения, используя реальные данные lvl: 3
      Переход к анализу решения на основе реальных данных журналов веб-серверов позволил значительно улучшить качество модели кластеризации. Реальные данные обеспечили более точное и всестороннее представление о поведении системы, включая различные виды запросов и потенциальные угрозы. Ниже представлена визуализация в трехмерном пространстве кластерного анализа реальных данных, которые разбиты уже на 20 кластеров(рис. 5) Рисунок 5 — визуализация кластерного анализа реальных данных
    len(DocSection.structure): 3 DocSection.name: 5 Обеспечение качества разработки, продукции, программного продукта  lvl: 2

      len(DocSection.structure): 0 DocSection.name: 5.1 Определение потребителей lvl: 3
      Потребителями разработанной системы могут быть: Системные администраторы: Используют систему для мониторинга и анализа событий веб-серверов, управления логами и выявления технических проблем, что помогает в обеспечении стабильности и доступности веб-сервисов. Специалисты по информационной безопасности: Применяют систему для обнаружения и реагирования на подозрительную активность и потенциальные угрозы безопасности, такие как вторжения или злоупотребления, что повышает уровень защиты данных и инфраструктуры. Аналитики данных: Используют систему для извлечения значимых инсайтов из данных журналов, таких как модели поведения пользователей и трафика, что способствует лучшему пониманию 
потребностей пользователей и оптимизации веб-контента. Разработчики веб-приложений: Интересуются системой как инструментом для отслеживания ошибок и недочетов в работе веб-приложений, а также для тестирования новых функций и изменений в коде. Управляющий персонал IT-департаментов: Могут использовать систему для стратегического планирования и оптимизации ресурсов, а также для обеспечения соответствия требованиям нормативно-правовых актов по обработке и хранению данных. Эти группы потребителей могут пользоваться системой для улучшения качества своей работы, повышения эффективности процессов, снижения рисков и обеспечения более высокого уровня удовлетворенности конечных пользователей. 5.2 Функции продукции  Для того, чтобы ответить на вопрос, какие функции имеет разработанный продукт, необходимо ввести определение функции изделия или услуги. Функции изделия или услуги – это требования и ожидания потребителя, которые могут быть установлены, предполагаются или являются обязательными. Функциональность разработанного программного продукта должна соответствовать требованиям потребителей. Для модели классификации событий это включает в себя: Автоматическую обработку и анализ больших объемов данных журналов. Высокую точность классификации событий для минимизации ложных срабатываний. Гибкость в настройке параметров для адаптации к специфике различных веб-серверов. Интеграцию с существующими системами мониторинга и управления. 5.3 Качество и характеристики  Для обеспечения качества разрабатываемого курса был проведен обзор стандартов, протоколов, отраслевых требований и современных лучших практик, нужных в разработке. При этом качество – степень соответствия совокупности присущих характеристик объекта требованиям (согласно ГОСТ Р ИСО 9000-2015). Знание протоколов, стандартов и пр. позволяет разработчикам обеспечить соответствие курса современным требованиям, повысить эффективность и удобство использования, улучшить качество курса.  Анализ функциональных требований к разработке отражен в таблице (таблица 5). Таблица 5 — Функциональные тербования
      len(DocSection.structure): 0 DocSection.name: 5.4 Измерение характеристик качества. Операциональное определение lvl: 3
      Операциональное определение (ОО) – это уточнение значения того или иного термина применительно к данной системе, находящейся в конкретных условиях и для людей, в ней задействованных. ОО необходим для уменьшения случаев разночтения и неоднозначности при общении между людьми, задействованными в системе, а также для более точного определения целей и задач, которые необходимо достичь.  ОО должно содержать как минимум три компоненты: Требования или стандарт, 
относительно которого оценивается результат измерения или испытания (критерий). Метод испытания или процедура измерения свойства объекта (тест) Процедура принятия решения (анализ), которое показывает, соответствует ли результат испытания стандарту.  Операциональные определения для разработанного курса отражены в таблице (таблица 6).  Таблица 6 — Операциональные определения. По итогам рассмотрения операциональных было определено, что разработанный курс удовлетворяет, описанным требованиям, однако существуют также предложения по улучшению продукта, которые сформулированы в таблице (таблица 7). Таблица 7 — Предложения по улучшению продукта.
      len(DocSection.structure): 0 DocSection.name: 5.5 Выводы lvl: 3
      Были определены потребители продукта, а также описаны ключевые функции конечного продукта. Осуществлен обзор существующих стандартов, отраслевых требований и современных лучших практик, необходимых в разработке. По итогам обзора сформулированы функциональные требования к разработанной модели. Описаны операциональные определения, характерные для модели классификации записей журналов веб-серверов и выявления аномалий. Сделан вывод о том, что разработанная 
модель удовлетворяет описанным требованиям, а также сформулировано предложение по дальнейшему улучшению модели.
    len(DocSection.structure): 0 DocSection.name: ЗАКЛЮЧЕНИЕ  lvl: 2
    Был проведен тщательный анализ существующих алгоритмов кластеризации, что позволило оценить их применимость для работы с журналами веб-серверов и выбрать наиболее эффективные в соответствии с задачами классификации событий. Разработанный алгоритм предварительной обработки данных оказался неотъемлемой частью исследования, поскольку он значительно повысил качество и точность последующей классификации.  Обработка включала в себя очистку данных, нормализацию, 
а также выбор и преобразование признаков, что создало надежную основу для обучения модели. Созданная модель классификации событий была обучена на реальных данных. Она продемонстрировала способность  различать типы событий, а также выделять среди них аномалии. Таким образом, результаты данной работы могут быть использованы для анализа событий журналов веб-серверов.